import pickle
import sys
import datetime

import agents
import time

import ghosts
import main


# helper to copy 2D arrays faster than deep copy
def deepcopy2D(arr):
    return [x if not isinstance(x, list) else x[:] for x in arr]

# inputs for subprocess call
min_ghosts = int(sys.argv[1])
max_ghosts = int(sys.argv[2])

# number of iterations for each ghost amount
num_iterations = main.num_iterations

# Call to open file where mazes generated by maze_generator are stored
with open('mazes.pickle', 'rb') as handle:
    maze_cache = pickle.load(handle)
print("Successfully loaded mazes from file!")
print(f"Starting Testing {min_ghosts} - {max_ghosts}!")
# arrays to hold results of each test
results_1 = []
results_2 = []
results_3 = []
results_4 = []
results_4_blind = []
results_5 = []

start = time.perf_counter()
for i in range(min_ghosts, max_ghosts):
    # values for each iteration of a ghost type
    agent_1_deaths = 0
    agent_2_deaths = 0
    agent_3_deaths = 0
    agent_4_deaths = 0
    agent_4_blind_deaths = 0
    agent_5_deaths = 0
    agent_1_time = 0
    agent_2_time = 0
    agent_3_time = 0
    agent_4_time = 0
    agent_4_blind_time = 0
    agent_5_time = 0
    print(f"Time since start: {((time.perf_counter() - start) / 60):0.2f} minute(s)")
    for j in range(num_iterations):
        generated_maze, visitable = maze_cache[j]  # pull mazes from array
        master_ghosts = ghosts.ghosts(maze_cache[j], i)  # creates shared ghost
        agent = agents.agent(deepcopy2D(generated_maze), visitable)

        # testing of each agent with a new copy of ghosts

        start_agent = time.perf_counter()
        if not agent.walk_agent_1(ghosts.ghosts((generated_maze, visitable), master_ghosts.num_ghosts, master_ghosts.nearest_ghost_queue, master_ghosts.ghost_occupy)):
            agent_1_deaths += 1
        agent_1_time += time.perf_counter() - start_agent

        start_agent = time.perf_counter()
        if not agent.walk_agent_2(ghosts.ghosts((generated_maze, visitable), master_ghosts.num_ghosts, master_ghosts.nearest_ghost_queue, master_ghosts.ghost_occupy)):
            agent_2_deaths += 1
        agent_2_time += time.perf_counter() - start_agent

        start_agent = time.perf_counter()
        if not agent.walk_agent_3(ghosts.ghosts((generated_maze, visitable), master_ghosts.num_ghosts, master_ghosts.nearest_ghost_queue, master_ghosts.ghost_occupy)):
            agent_3_deaths += 1
        agent_3_time += time.perf_counter() - start_agent

        start_agent = time.perf_counter()
        if not agent.walk_agent_4(ghosts.ghosts((generated_maze, visitable), master_ghosts.num_ghosts, master_ghosts.nearest_ghost_queue, master_ghosts.ghost_occupy)):
            agent_4_deaths += 1
        agent_4_time += time.perf_counter() - start_agent

        start_agent = time.perf_counter()
        if not agent.walk_agent_4_blind(ghosts.ghosts((generated_maze, visitable), master_ghosts.num_ghosts, master_ghosts.nearest_ghost_queue, master_ghosts.ghost_occupy)):
            agent_4_blind_deaths += 1
        agent_4_blind_time += time.perf_counter() - start_agent

        start_agent = time.perf_counter()
        if not agent.walk_agent_5(ghosts.ghosts((generated_maze, visitable), master_ghosts.num_ghosts, master_ghosts.nearest_ghost_queue, master_ghosts.ghost_occupy)):
            agent_5_deaths += 1
        agent_5_time += time.perf_counter() - start_agent
        print(f"Iteration: {j} out of {num_iterations} | Ghosts: {i} | {datetime.datetime.now()}")

    # saving results
    results_1.append([i, (num_iterations - agent_1_deaths) / num_iterations, agent_1_time])
    results_2.append([i, (num_iterations - agent_2_deaths) / num_iterations, agent_2_time])
    results_3.append([i, (num_iterations - agent_3_deaths) / num_iterations, agent_3_time])
    results_4.append([i, (num_iterations - agent_4_deaths) / num_iterations, agent_4_time])
    results_4_blind.append([i, (num_iterations - agent_4_blind_deaths) / num_iterations, agent_4_blind_time])
    results_5.append([i, (num_iterations - agent_5_deaths) / num_iterations, agent_5_time])

    # console output
    print(f"Survival Rate for {i} ghost(s): ")
    print(f"Agent 1: ", (num_iterations - agent_1_deaths) / num_iterations)
    print(f"Agent 2: ", (num_iterations - agent_2_deaths) / num_iterations)
    print(f"Agent 3: ", (num_iterations - agent_3_deaths) / num_iterations)
    print(f"Agent 4: ", (num_iterations - agent_4_deaths) / num_iterations)
    print(f"Agent 4 Blind: ", (num_iterations - agent_4_blind_deaths) / num_iterations)
    print(f"Agent 5: ", (num_iterations - agent_5_deaths) / num_iterations)
    print(f"Time since start: {((time.perf_counter() - start) / 60):0.2f} minute(s)")
    print()

# output results to file
with open(f'agent_1_testing/agent_1_{min_ghosts}_{max_ghosts}.pickle', 'wb') as handle:
    pickle.dump(results_1, handle, protocol=pickle.HIGHEST_PROTOCOL)
with open(f'agent_2_testing/agent_2_{min_ghosts}_{max_ghosts}.pickle', 'wb') as handle:
    pickle.dump(results_2, handle, protocol=pickle.HIGHEST_PROTOCOL)
with open(f'agent_3_testing/agent_3_{min_ghosts}_{max_ghosts}.pickle', 'wb') as handle:
    pickle.dump(results_3, handle, protocol=pickle.HIGHEST_PROTOCOL)
with open(f'agent_4_testing/agent_4_{min_ghosts}_{max_ghosts}.pickle', 'wb') as handle:
    pickle.dump(results_4, handle, protocol=pickle.HIGHEST_PROTOCOL)
with open(f'agent_4_testing/agent_4_blind_{min_ghosts}_{max_ghosts}.pickle', 'wb') as handle:
    pickle.dump(results_4_blind, handle, protocol=pickle.HIGHEST_PROTOCOL)
with open(f'agent_5_testing/agent_5_{min_ghosts}_{max_ghosts}.pickle', 'wb') as handle:
    pickle.dump(results_5, handle, protocol=pickle.HIGHEST_PROTOCOL)
